{"version":3,"sources":["../src/index.js"],"names":["rqt","address","config","data","contentType","headers","version","binary","returnHeaders","er","opts","url","parse","isHttps","protocol","request","https","http","options","hostname","port","path","method","Buffer","byteLength","h","body","Promise","resolve","reject","req","res","catchment","Catchment","pipe","r","promise","parsed","JSON","e","err","postData","on","error","write","end"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;AAEA;;;;;;;;;;;AAWe,eAAeA,GAAf,CAAmBC,OAAnB,EAA4BC,SAAS,EAArC,EAAyC;AACtD,QAAM;AACJC,WAAO,IADH;AAEJC,kBAAc,kBAFV;AAGJC,cAAU;AACR,oBAAe,6BAA4BC,gBAAQ;AAD3C,KAHN;AAMJC,aAAS,KANL;AAOJC,oBAAgB;AAPZ,MAQFN,MARJ;AASA,QAAMO,KAAK,qBAAO,IAAP,CAAX;;AACA,QAAMC,OAAOC,aAAIC,KAAJ,CAAUX,OAAV,CAAb;;AACA,QAAMY,UAAUH,KAAKI,QAAL,KAAkB,QAAlC;AACA,QAAMC,UAAUF,UAAUG,cAAV,GAAkBC,aAAlC;AACA,QAAMC,UAAU;AACdC,cAAUT,KAAKS,QADD;AAEdC,UAAMV,KAAKU,IAFG;AAGdC,UAAMX,KAAKW,IAHG;AAIdhB;AAJc,GAAhB;;AAMA,MAAIF,IAAJ,EAAU;AACRe,YAAQI,MAAR,GAAiB,MAAjB;AACAJ,YAAQb,OAAR,GAAkB,EAChB,GAAGa,QAAQb,OADK;AAEhB,sBAAgBD,WAFA;AAGhB,wBAAkBmB,OAAOC,UAAP,CAAkBrB,IAAlB;AAHF,KAAlB;AAKD;;AACD,MAAIsB,CAAJ;AACA,QAAMC,OAAO,MAAM,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAClD,UAAMC,MAAMf,QACVG,OADU,EAEV,MAAOa,GAAP,IAAe;AACb,YAAMC,YAAY,IAAIC,kBAAJ,CAAc;AAAE1B;AAAF,OAAd,CAAlB;AACAwB,UAAIG,IAAJ,CAASF,SAAT;AACA,YAAMG,IAAI,MAAMH,UAAUI,OAA1B;AACAX,UAAIM,IAAI1B,OAAR;;AACA,UAAI0B,IAAI1B,OAAJ,CAAY,cAAZ,MAAgC,kBAApC,EAAwD;AACtD,YAAI;AACF,gBAAMgC,SAASC,KAAK1B,KAAL,CAAWuB,CAAX,CAAf;AACAP,kBAAQS,MAAR;AACD,SAHD,CAGE,OAAOE,CAAP,EAAU;AACV,gBAAMC,MAAM/B,GAAG8B,CAAH,CAAZ;AACAC,cAAIC,QAAJ,GAAeN,CAAf;AACAN,iBAAOW,GAAP;AACD;AACF,OATD,MASO;AACLZ,gBAAQO,CAAR;AACD;AACF,KAnBS,EAoBVO,EApBU,CAqBV,OArBU,EAsBTC,KAAD,IAAW;AACT,YAAMH,MAAM/B,GAAGkC,KAAH,CAAZ;AACAd,aAAOW,GAAP;AACD,KAzBS,CAAZ;;AA2BA,QAAIrC,IAAJ,EAAU;AACR2B,UAAIc,KAAJ,CAAUzC,IAAV;AACD;;AACD2B,QAAIe,GAAJ;AACD,GAhCkB,CAAnB;AAiCA,MAAIrC,aAAJ,EAAmB,OAAO;AAAEkB,QAAF;AAAQrB,aAASoB;AAAjB,GAAP;AACnB,SAAOC,IAAP;AACD;AAED","sourcesContent":["import { request as http } from 'http'\nimport { request as https } from 'https'\nimport Catchment from 'catchment'\nimport url from 'url'\nimport erotic from 'erotic'\nimport { version } from '../package.json'\n\n/**\n * Request an HTTP page. If `returnHeaders` is set to true, an object will be returned.\n * @param {string} address Url such as http://example.com/api\n * @param {Config} [config] Configuration object\n * @param {object} [config.data] Data to send to the server using a post request.\n * @param {string} [config.contentType] Content-Type header. Default `application/json`.\n * @param {object} [config.headers] A map of headers to use in the request.\n * @param {boolean} [config.binary] Whether to return a buffer. Default false.\n * @param {boolean} [config.returnHeaders] Return an object with `body` and `headers` properties instead of just the response.\n * @returns {Promise.<string|Buffer|{ body: string|Buffer, headers: Object.<string, string> }>} A string or buffer as a response. If `config.headers` was set, an object is returned.\n */\nexport default async function rqt(address, config = {}) {\n  const {\n    data = null,\n    contentType = 'application/json',\n    headers = {\n      'User-Agent': `Mozilla/5.0 (Node.js) rqt/${version}`,\n    },\n    binary = false,\n    returnHeaders = false,\n  } = config\n  const er = erotic(true)\n  const opts = url.parse(address)\n  const isHttps = opts.protocol === 'https:'\n  const request = isHttps ? https : http\n  const options = {\n    hostname: opts.hostname,\n    port: opts.port,\n    path: opts.path,\n    headers,\n  }\n  if (data) {\n    options.method = 'POST'\n    options.headers = {\n      ...options.headers,\n      'Content-Type': contentType,\n      'Content-Length': Buffer.byteLength(data),\n    }\n  }\n  let h\n  const body = await new Promise((resolve, reject) => {\n    const req = request(\n      options,\n      async (res) => {\n        const catchment = new Catchment({ binary })\n        res.pipe(catchment)\n        const r = await catchment.promise\n        h = res.headers\n        if (res.headers['content-type'] === 'application/json') {\n          try {\n            const parsed = JSON.parse(r)\n            resolve(parsed)\n          } catch (e) {\n            const err = er(e)\n            err.postData = r\n            reject(err)\n          }\n        } else {\n          resolve(r)\n        }\n      },\n    ).on(\n      'error',\n      (error) => {\n        const err = er(error)\n        reject(err)\n      },\n    )\n    if (data) {\n      req.write(data)\n    }\n    req.end()\n  })\n  if (returnHeaders) return { body, headers: h }\n  return body\n}\n\n/**\n * @typedef {Object} Config\n * @property {object} [data] Data to send to the server.\n * @property {string} [contentType] Content-Type header.\n * @property {object} [headers] A map of headers.\n * @property {boolean} [binary] Whether to return a buffer.\n * @property {boolean} [returnHeaders] Return an object with `body` and `headers` properties instead of just the response.\n */\n"],"file":"index.js"}